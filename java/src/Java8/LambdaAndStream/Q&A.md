
# Що таке Stream API в Java?
   **Stream API - це частина Java API, яка надає функціональність для обробки потоків даних. Він дозволяє виконувати операції над колекціями даних або послідовностями елементів без прямого втручання у структуру даних.**
# Що таке Lambda-вирази в Java?
   **Lambda-вирази - це анонімні функції, які можуть бути передані як параметри або збережені в змінних. Вони дозволяють писати більш компактний та ефективний код шляхом визначення функціональності без необхідності великої кількості додаткового коду.**
#  Які основні операції доступні в Stream API?
   **У Stream API доступні різні операції, включаючи фільтрацію, мапування, сортування, об'єднання, згортання, групування та інші. Ці операції дозволяють маніпулювати потоками даних та виконувати різні дії над елементами потоку.**
# Які інтерфейси використовуються в Stream API?
   **У Stream API використовуються різні інтерфейси, такі як Predicate, Consumer, Function, Supplier, Comparator та інші. Ці інтерфейси використовуються для визначення функціональних інтерфейсів, які потрібні для виконання операцій над потоками даних.**
# Яка різниця між проміжними та термінальними операціями в Stream API?
   **Проміжні операції виконуються на потоці даних та можуть бути пов'язані одна з одною. Вони не виконують жодних операцій над даними, але повертають новий потік з модифікованими даними. Термінальні операції виконують операції над даними та повертають результат або здійснюють побічний ефект, такий як вивід на екран.**
# Які переваги використання Stream та Lambda в Java?
   **Використання Stream та Lambda дозволяє писати більш зрозумілий та елегантний код, спрощує маніпулювання та обробку даних, полегшує паралельне виконання операцій та забезпечує високу продуктивність. Вони також сприяють підвищенню читабельності коду та зменшенню кількості зайвого коду.**
# В яких ситуаціях краще використовувати Stream та Lambda в Java?
   **Stream та Lambda є потужними інструментами для обробки даних, і вони можуть бути використані в багатьох ситуаціях. Найбільш підходящі ситуації для їх використання включають обробку та фільтрацію великих наборів даних, мапування та перетворення даних, виконання послідовності дій над даними, а також паралельну обробку для поліпшення продуктивності.**
______________________________________________________________________________________________________________________

# Що таке Optional?
**Optional є класом в Java, який введений з метою боротьби з потенційними проблемами нульових значень (null) та вдосконаленням безпеки при роботі зі значеннями, які можуть бути відсутніми.**

**Optional визначає контейнер для значення, яке може бути присутнім або відсутнім. Він надає зручні методи для роботи з цим значенням без необхідності перевірки на null.**

**Основні особливості Optional:**

1. Optional може містити одне значення або бути пустим (відсутнім значенням).
2. Використання Optional підвищує читабельність коду та зменшує ризик NullPointerException.
3. Optional надає безпечний спосіб роботи зі значеннями, які можуть бути відсутніми, за допомогою методів, таких як get(), isPresent(), ifPresent(), orElse() та ін.
4. Використання Optional сприяє покращенню документації коду та допомагає зрозуміти, що значення може бути відсутнім.

**Приклад використання Optional:**

```java
Optional<String> optionalValue = Optional.ofNullable(getValueFromSomewhere());
optionalValue.ifPresent(value -> System.out.println("Value is present: " + value));
String result = optionalValue.orElse("Default Value");
```

У цьому прикладі `optionalValue` містить значення, отримане з деякого джерела. Метод `ifPresent()` перевіряє, чи присутнє значення, і якщо так, виводить його на екран. Метод `orElse()` повертає значення, якщо воно присутнє, або значення "Default Value", якщо воно відсутнє.
Використання Optional допомагає покращити безпеку та читабельність коду, дозволяючи легко та елегантно обробляти випадки відсутності значень.

# Що таке згортання (reduce) колекцій?
**Згортання (reduce) колекцій - це операція, яка дозволяє об'єднувати всі елементи колекції в одне значення. Ця операція виконується за допомогою бінарної операції (BinaryOperator), яка об'єднує два елементи в одне.**

**Операція згортання може бути корисною в різних сценаріях, таких як обчислення суми елементів, знаходження максимального або мінімального елемента, конкатенація рядків та інші операції, які вимагають об'єднання даних в одне значення.**

**У Java згортання колекцій може бути виконане за допомогою методу `reduce()` у класі Stream або за допомогою методу `reduce()` у класі Stream API.**

**Синтаксис методу `reduce()` у Stream API:**

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
T reduce(T identity, BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
```

- Перший варіант методу `reduce()` використовується, коли ми хочемо згорнути всі елементи потоку в одне значення з допомогою бінарного оператора.
- Другий варіант методу `reduce()` дозволяє вказати початкове значення (identity), яке використовується як початкове значення для згортання.
- Третій варіант методу `reduce()` використовується, коли ми працюємо з паралельним потоком та ми маємо комбінатор, який об'єднує проміжні результати обробки потоку.

**Приклад використання методу `reduce()` для обчислення суми елементів списку:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);
System.out.println("Sum: " + sum);
```

**У цьому прикладі ми використовуємо метод `reduce()` для згортання елементів списку у суму. Початкове значення встановлено на 0, а бінарний оператор `(a, b) -> a + b` об'єднує два елементи, додаючи їх разом.**

# Що таке паралельні потоки?
**Паралельні потоки (Parallel Streams) в Java є механізмом, який дозволяє виконувати обробку елементів потоку паралельно у багатьох потоках, що призводить до поліпшення продуктивності та зменшення часу виконання завдань.**

**Паралельні потоки використовуються у контексті Stream API в Java для обробки великих об'ємів даних. Вони автоматично розподіляють обробку елементів потоку між доступними потоками в системі, що дозволяє використовувати потенціал багатоядерних та багатопроцесорних систем.**

- **parallelStream() є методом в Java, який використовується для створення паралельного потоку даних з колекцій або інших джерел даних.**

**Основні особливості паралельних потоків:**

1. Автоматичний розподіл завдань: Паралельні потоки автоматично розподіляють обробку елементів потоку між доступними потоками, що дозволяє використовувати багатоядерні та багатопроцесорні системи для поліпшення продуктивності.
2. Збереження порядку даних: Паралельні потоки забезпечують правильну обробку елементів потоку, зберігаючи їх початковий порядок. Результати обробки виводяться у правильному порядку відповідно до послідовності елементів у потоці.
3. Управління потоками: Java самостійно керує створенням та керуванням потоками, що дозволяє спростити роботу з паралельними потоками без необхідності вручну створювати та керувати потоками.
4. Безпека: Паралельні потоки враховують потенційні проблеми багатопотокової обробки, такі як заблокування, зміни спільних ресурсів та інші багатопотокові проблеми. Вони забезпечують безпеку виконання завдяки внутрішньому механізму синхронізації.

**Використання паралельних потоків дозволяє ефективно обробляти великі об'єми даних, розподіляючи роботу між багатьма потоками та використовуючи можливості багатоядерних та багатопроцесорних систем. Однак, варто враховувати особливості паралельної обробки, такі як синхронізація та безпека, для ефективного використання цього механізму.**

# Які інтерфейси є у Stream?

1. Stream<T>: Представляє послідовний потік елементів типу T.
2. IntStream, LongStream, DoubleStream: Спеціалізовані потоки для цілих чисел, довгих чисел і чисел з плаваючою крапкою відповідно.
3. BaseStream: Базовий інтерфейс для всіх Stream, надає загальні операції, спільні для всіх типів Stream.
4. Collector: Використовується для збору елементів потоку в різні контейнери або результати.
5. Spliterator: Використовується для розділення послідовності елементів потоку на частини для паралельної обробки.
6. Iterator: Інтерфейс для послідовного отримання елементів з колекції або послідовності.
7. Predicate: Використовується для перевірки умови на елементі потоку. Повертає значення типу boolean.
8. Function: Використовується для перетворення одного типу даних в інший або отримання результату на основі вхідних даних.
9. Consumer: Використовується для виконання дій над елементами потоку без повернення результату.
10. Supplier: Використовується для створення або надання елементів потоку без вхідних даних.
11. Comparator: Використовується для порівняння елементів потоку.
12. BiPredicate, BiFunction, BiConsumer: Подібні до Predicate, Function і Consumer, але приймають два аргументи замість одного.

**Ці інтерфейси дозволяють робити різноманітні операції з потоками даних, виконувати фільтрацію, мапування, згортання, 
сортування та інші операції.
Кожен інтерфейс має свої власні методи, які виконують певні функціональні дії з елементами потоку.**



# Навіщо в Stream використовують Predicate, Consumer, Function?

**Використання інтерфейсів Predicate, Consumer і Function в Stream дозволяє робити операції з елементами потоку, які можуть змінювати, фільтрувати або перетворювати дані. Вони допомагають виконувати різні дії над елементами потоку, що робить операції більш гнучкими та зручними для програмування.**

## Ось які ролі виконують ці інтерфейси в Stream:
____________________________
## 1. Predicate: 
**Predicate використовується для фільтрації елементів потоку. Він дозволяє вказати умову, яку повинні задовольняти елементи, щоб бути включеними в результат. При використанні методу `filter()` потоку, Predicate визначає, які елементи будуть пропущені через фільтр.**

**У Java, інтерфейс Predicate є частиною пакету java.util.function і використовується для представлення логічної умови, яка може бути перевірена для певного об'єкта. Він приймає один аргумент і повертає булеве значення, вказуючи, чи задовольняє даний об'єкт вказану умову.**

**Інтерфейс Predicate має один абстрактний метод:**

```java
boolean test(T t);
```
**Цей метод використовується для перевірки умови на об'єкті типу T. Він повертає значення true, якщо об'єкт задовольняє умову, і false в іншому випадку.**

**Predicate може бути використаний в різних сценаріях, наприклад:**

1. Фільтрація елементів: Предикати можуть використовуватись для фільтрації колекцій або потоків елементів, залишаючи лише ті елементи, які задовольняють певну умову.
2. Перевірка умови: Предикати можуть бути використані для перевірки певних умов на об'єктах, наприклад, чи є число парним, чи має рядок певну довжину тощо.
3. Складні умови: Предикати можуть бути поєднані за допомогою логічних операцій (AND, OR, NOT) для створення складних умов, що можуть бути перевірені на об'єктах.

**Наведемо приклад використання Predicate для фільтрації елементів списку:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Predicate<Integer> evenPredicate = number -> number % 2 == 0;
List<Integer> evenNumbers = numbers.stream()
                                   .filter(evenPredicate)
                                   .collect(Collectors.toList());
System.out.println(evenNumbers); // Output: [2, 4]
```

**У цьому прикладі ми використовуємо Predicate для створення умови, яка перевіряє, чи є число парним. Потім ми використовуємо цей Predicate для фільтрації чисел у списку, залишаючи лише парні числа.**

## 2. Consumer: 
**Consumer використовується для виконання дій над елементами потоку без повернення результату. Він дозволяє вказати, яку дію потрібно виконати з кожним елементом потоку. При використанні методів `forEach()` або `peek()` потоку, Consumer визначає, яку дію потрібно виконати над кожним елементом.**

**У Java, інтерфейс Consumer є частиною пакету java.util.function і використовується для виконання дії над об'єктом без повернення результату. Він приймає один аргумент і нічого не повертає.**

**Інтерфейс Consumer має один абстрактний метод:**

```java
void accept(T t);
```
**Цей метод приймає об'єкт типу T і виконує певну дію над цим об'єктом. Метод не повертає жодного значення.**

**Consumer може бути використаний в різних сценаріях, наприклад:**

1. Обробка елементів: Consumer може бути використаний для обробки кожного елемента в колекції або потоці даних без повернення результату. Наприклад, він може виконувати друк елементів, запис у файл або оновлення стану об'єктів.
2. Передача дій: Consumer може бути використаний для передачі дій (функцій) як аргументів у інші методи. Наприклад, він може бути використаний для передачі дії, яку потрібно виконати над кожним елементом, в метод `forEach()` колекцій або потоків.
3. Складні операції: Consumer може бути поєднаний з іншими функціональними інтерфейсами для створення складних операцій. Наприклад, використання Consumer разом з Predicate і Function може дозволити фільтрувати елементи та виконувати певну дію над ними.

**Приведемо приклад використання Consumer для виводу елементів списку:**

```java
List<String> names = Arrays.asList("John", "Alice", "Bob");
Consumer<String> printConsumer = name -> System.out.println(name);
names.forEach(printConsumer);
```

**У цьому прикладі ми створюємо Consumer, який просто друкує кожне ім'я. Потім ми використовуємо цей Consumer разом з методом `forEach()`, щоб виконати цю дію над кожним елементом списку `names`.**

## 3.Function: 

**Function використовується для перетворення елементів потоку з одного типу на інший або для отримання результату на основі вхідних даних. Він дозволяє вказати, як перетворити або обробити кожен елемент потоку для отримання вихідних результатів. При використанні методів `map()`, `flatMap()` або `reduce()` потоку, Function визначає, як обчислити нове значення або перетворити елементи потоку.**

**У Java, інтерфейс Function є частиною пакету java.util.function і використовується для визначення функцій, які приймають один аргумент і повертають результат. Він представляє функцію, яка може бути застосована до об'єкта одного типу для отримання об'єкта іншого типу.**

**Інтерфейс Function має один абстрактний метод:**

```java
R apply(T t);
```
**Цей метод приймає об'єкт типу T і повертає об'єкт типу R. Він описує дію, яка застосовується до вхідного об'єкта для отримання вихідного об'єкта.**

**Function може бути використаний в різних сценаріях, наприклад:**

1. Мапування елементів: Function може бути використаний для мапування (перетворення) елементів з одного типу на інший. Наприклад, він може бути використаний для перетворення чисел з одного типу на інший або для отримання деякої властивості об'єкта.
2. Обробка даних: Function може бути використаний для обробки даних шляхом застосування деяких операцій до вхідних об'єктів та отримання вихідних результатів. Наприклад, він може бути використаний для обчислення середнього значення елементів, об'єднання рядків тощо.
3. Послідовні операції: Function може бути поєднаний з іншими функціональними інтерфейсами для створення послідовних операцій. Наприклад, використання Function разом з Predicate і Consumer може дозволити фільтрувати елементи, обробляти їх і виконувати певні дії.

**Приведемо приклад використання Function для мапування чисел на їх квадрати:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Function<Integer, Integer> squareFunction = number -> number * number;
List<Integer> squares = numbers.stream()
                               .map(squareFunction)
                               .collect(Collectors.toList());
System.out.println(squares); // Output: [1, 4, 9, 16, 25]
```

**У цьому прикладі ми створюємо Function, який мапує числа на їх квадрати. Потім ми використовуємо цей Function разом з методом `map()` потоку чисел, щоб застосувати функцію до кожного числа та отримати список квадратів чисел.**
________________
### _Використання цих інтерфейсів дозволяє програмістам легко виконувати різні операції з елементами потоку, такі як фільтрація, обробка та перетворення даних. Вони дозволяють писати більш зрозумілий і компактний код, який може бути легко змінений або розширений у майбутньому_
________________
