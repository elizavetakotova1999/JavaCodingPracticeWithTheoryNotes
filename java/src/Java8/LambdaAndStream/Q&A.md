
# Що таке `Stream` API в Java?
   **Stream API - це частина Java API, яка надає функціональність для обробки потоків даних. Він дозволяє виконувати операції над колекціями даних або послідовностями елементів без прямого втручання у структуру даних.**
  
**Stream є потужним інструментом для обробки та маніпулювання колекціями даних. Він є новим підходом до роботи з послідовностями об'єктів, де дозволяється виконувати операції з високим рівнем абстракції, такі як `фільтрація`, `трансформація`, об'`єднання`, `згортання` та багато інших.**

**Основні особливості `Stream` включають:**

1. Послідовність елементів: Stream представляє послідовну послідовність елементів, яку можна обробляти один за одним.
2. Потокові операції: Stream надає набір потокових операцій, таких як `filter`, `map`, `reduce`, `collect` та інші. Ці операції дозволяють виконувати різні операції з елементами потоку.
3. Лінива обробка: Багато з операцій Stream є лінивими, що означає, що вони виконуються тільки при необхідності та на вимогу. Це дозволяє оптимізувати продуктивність та ресурси.
4. Паралельна обробка: Stream також надає можливість паралельної обробки даних, що дозволяє використовувати багатопотоковість для прискорення обчислень на великих наборах даних.
5. Незмінність даних: Stream зазвичай працює з незмінними даними, що сприяє безпеки та універсальності операцій.

**Основна ідея за використання `Stream` полягає в тому, що ви можете визначити потік операцій над колекцією, що дозволяє вам
здійснювати складні операції на даних з меншим кодом та більшим рівнем абстракції.**

**Ось приклад використання `Stream` для фільтрації та обчислення суми чисел:**

``` java 
import java.util.Arrays;
import java.util.List;

public class StreamExample {
public static void main(String[] args) {
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        int sum = numbers.stream()
                         .filter(number -> number % 2 == 0)
                         .mapToInt(number -> number)
                         .sum();

        System.out.println(sum); // Вивід: 6
    }
}
```
**У цьому прикладі ми використовуємо Stream для фільтрації лише парних чисел, використовуючи `filter()`, потім мапуємо числа до примітивного типу `int` за допомогою `mapToInt()`, і нарешті обчислюємо суму за допомогою `sum()`.**

# Що таке Lambda-вирази в Java?
   **Лямбда-вираз (`Lambda`) в Java - це спосіб виразити функціональність анонімного класу, який може бути переданий
   як параметр або використаний для реалізації функціонального інтерфейсу.**

**Основні риси лямбда-виразів:**

1. `Скорочений синтаксис`: Лямбда-вирази надають можливість замінити довгий синтаксис анонімних класів більш компактним і
   зрозумілішим виразом.

2. `Анонімність`: Лямбда-вирази є анонімними, тобто вони не мають імені. Вони використовуються тільки там, де потрібно
   передати функцію або виконати певні дії.

3. `Функціональний інтерфейс`: Лямбда-вирази використовуються для реалізації функціональних інтерфейсів, які містять
   лише один абстрактний метод. Це дозволяє використовувати лямбда-вирази як коротку заміну для інтерфейсних реалізацій.

4. `Передача функцій як параметрів`: Лямбда-вирази дозволяють передавати функції як параметри в методи, що дозволяє
   створювати більш гнучкі та зрозуміліші API.

5. `Замикання (Closures)`: Лямбда-вирази можуть отримувати доступ до змінних, які знаходяться в області видимості,
   де вони були створені. Це дозволяє передавати та маніпулювати значеннями в лямбда-виразах.

______________________________________
**Лямбда-вирази в Java дозволяють передати функціональну функцію або блок коду як параметр до методу або
використовувати їх для реалізації функціональних інтерфейсів. Ось як працюють лямбда-вирази:**

1. `Визначення функціонального інтерфейсу`: Перш за все, потрібно визначити функціональний інтерфейс, тобто інтерфейс,
   який містить тільки один абстрактний метод. Цей метод буде виконуватись лямбда-виразом.

2. `Використання лямбда-виразу`: Лямбда-вираз можна передати як аргумент до методу або використовувати для реалізації
   функціонального інтерфейсу. Лямбда-вираз складається з параметрів, стрілки `->` та тіла лямбда-виразу.

3. `Збіг параметрів із методом інтерфейсу`: Параметри лямбда-виразу повинні збігатися з параметрами методу функціонального
   інтерфейсу, а типи параметрів можуть бути інферовані компілятором Java.

4. `Виконання тіла лямбда-виразу`: При виклику методу або використанні функціонального інтерфейсу з лямбда-виразом,
   виконується тіло лямбда-виразу, яке міститься після стрілки `->`. Це може бути один вираз або блок коду, який
   виконується в контексті виклику.

5. `Повернення результату`: Якщо тіло лямбда-виразу повертає значення, це значення може бути повернуте з методу або
   використане в контексті виклику.

**Лямбда-вирази дозволяють створювати короткі, зрозумілі та економічні функції, які можуть бути передані як параметри
або використані для реалізації функціональних інтерфейсів. Вони полегшують роботу з функціональним програмуванням та
дозволяють писати більш зрозумілий та компактний код.**
______________________________________
**У Java існує кілька видів лямбда-виразів, в залежності від кількості параметрів та тіла лямбда-виразу:**

1. Лямбда-вираз без параметрів:
```java
        //() -> { // тіло лямбда-виразу };
        Runnable runnable = () -> {
        System.out.println("Hello, Lambda!");
        };

```


Цей тип лямбда-виразу не приймає жодних параметрів.

2. Лямбда-вираз з одним параметром:
```java
        //(parameter) -> { // тіло лямбда-виразу };
        Consumer<String> printer = message -> {
        System.out.println(message);
        };

```
Цей тип лямбда-виразу має один параметр.

3. Лямбда-вираз з більш ніж одним параметром:
```java
        //(parameter1, parameter2, ...) -> { // тіло лямбда-виразу };
        BinaryOperator<Integer> add = (a, b) -> {
                return a + b;
                };

```
Цей тип лямбда-виразу має більше одного параметра.

4. Скорочений лямбда-вираз:
```java
        //(parameter) -> expression;
        Predicate<Integer> isEven = n -> n % 2 == 0;
```
Це скорочений синтаксис лямбда-виразу, який використовується, коли тіло лямбда-виразу складається з одного
виразу, який повертається безпосередньо.

5. Посилання на метод:
```java
        //ClassName::methodName
        List<String> names = Arrays.asList("John", "Mary", "Alice");
                names.forEach(System.out::println);
```
Це спеціальний вид лямбда-виразу, який дозволяє посилатися на існуючий метод замість описування нового тіла лямбда-виразу.


#  Які основні операції доступні в Stream API?
**У Stream API доступні різні операції, включаючи `фільтрацію`, `мапування`, `сортування`,` об'єднання`, `згортання`, `групування` та інші. Ці операції дозволяють маніпулювати потоками даних та виконувати різні дії над елементами потоку.**

# Які інтерфейси використовуються в Stream API?
   **У Stream API використовуються різні інтерфейси, такі як `Predicate`, `Consumer`, `Function`, `Supplier`, `Comparator` та інші. Ці інтерфейси використовуються для визначення функціональних інтерфейсів, які потрібні для виконання операцій над потоками даних.**

# Яка різниця між проміжними та термінальними операціями в Stream API?
   **Проміжні операції виконуються на потоці даних та можуть бути пов'язані одна з одною. Вони не виконують жодних операцій над даними, але повертають новий потік з модифікованими даними. Термінальні операції виконують операції над даними та повертають результат або здійснюють побічний ефект, такий як вивід на екран.**

# Які переваги використання Stream та Lambda в Java?
 **Використання Stream та Lambda дозволяє писати більш зрозумілий та елегантний код, спрощує маніпулювання та обробку даних, полегшує паралельне виконання операцій та забезпечує високу продуктивність. Вони також сприяють підвищенню читабельності коду та зменшенню кількості зайвого коду.**

 _**`Stream` і `Lambda` в Java працюють разом для забезпечення потужних можливостей обробки даних.**_

**Основні кроки в роботі з `Stream` та `Lambda-виразами`:**

1. Створення потоку: Спочатку створюється початковий потік, зазвичай з колекції або іншого джерела даних. Наприклад, `List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5); Stream<Integer> stream = numbers.stream();`

2. Виконання проміжних операцій: За допомогою проміжних операцій, таких як `filter`, `map`, `sorted` та інші, оброблюються елементи потоку. Ці операції можуть використовувати лямбда-вирази для визначення умов, трансформацій або сортування. Наприклад, `Stream<Integer> evenStream = stream.filter(number -> number % 2 == 0);`

3. Застосування кінцевих операцій: Після виконання проміжних операцій, застосовуються кінцеві операції, такі як `collect`, `forEach`, `reduce`, `count` та інші, щоб отримати результат або виконати певну дію. Ці операції можуть також використовувати лямбда-вирази для визначення дій або обчислень. Наприклад, `List<Integer> evenNumbers = evenStream.collect(Collectors.toList());`

**Основна ідея полягає в тому, що лямбда-вирази використовуються для визначення функцій або дій, які застосовуються до елементів потоку. Це дозволяє здійснювати гнучкі трансформації та операції над потоком даних, забезпечуючи чистий та експресивний код.**

**Наприклад, у прикладі вище, лямбда-вираз `number -> number % 2 == 0` використовується для визначення умови фільтрації парних чисел у потоці. Аналогічно, лямбда-вирази можуть бути використані для визначення функцій мапування, згортання, сортування та багатьох інших операцій з `Stream`.**

**Таке поєднання `Stream` та лямбда-виразів дозволяє забезпечити зручну та потужну обробку даних в Java з меншим обсягом коду та більшою експресивністю.**
# В яких ситуаціях краще використовувати Stream та Lambda в Java?
   **Stream та Lambda є потужними інструментами для обробки даних, і вони можуть бути використані в багатьох ситуаціях. Найбільш підходящі ситуації для їх використання включають обробку та фільтрацію великих наборів даних, мапування та перетворення даних, виконання послідовності дій над даними, а також паралельну обробку для поліпшення продуктивності.**
______________________________________________________________________________________________________________________

# Що таке Optional?
**Optional є класом в Java, який введений з метою боротьби з потенційними проблемами нульових значень (`null`) та вдосконаленням безпеки при роботі зі значеннями, які можуть бути відсутніми.**

**Optional визначає контейнер для значення, яке може бути присутнім або відсутнім. Він надає зручні методи для роботи з цим значенням без необхідності перевірки на null.**

**Основні особливості `Optional`:**

1. Optional може містити одне значення або бути пустим (відсутнім значенням).
2. Використання Optional підвищує читабельність коду та зменшує ризик `NullPointerException`.
3. Optional надає безпечний спосіб роботи зі значеннями, які можуть бути відсутніми, за допомогою методів, таких як `get()`, `isPresent()`, `ifPresent()`, `orElse()` та ін.
4. Використання Optional сприяє покращенню документації коду та допомагає зрозуміти, що значення може бути відсутнім.

**Приклад використання Optional:**

```java
Optional<String> optionalValue = Optional.ofNullable(getValueFromSomewhere());
optionalValue.ifPresent(value -> System.out.println("Value is present: " + value));
String result = optionalValue.orElse("Default Value");
```

У цьому прикладі `optionalValue` містить значення, отримане з деякого джерела. Метод `ifPresent()` перевіряє, чи присутнє значення, і якщо так, виводить його на екран. Метод `orElse()` повертає значення, якщо воно присутнє, або значення "Default Value", якщо воно відсутнє.
Використання Optional допомагає покращити безпеку та читабельність коду, дозволяючи легко та елегантно обробляти випадки відсутності значень.

# Що таке згортання (reduce) колекцій?
**Згортання (`reduce`) колекцій - це операція, яка дозволяє об'єднувати всі елементи колекції в одне значення. Ця операція виконується за допомогою бінарної операції (BinaryOperator), яка об'єднує два елементи в одне.**

**Операція згортання може бути корисною в різних сценаріях, таких як обчислення суми елементів, знаходження максимального або мінімального елемента, конкатенація рядків та інші операції, які вимагають об'єднання даних в одне значення.**

**У Java згортання колекцій може бути виконане за допомогою методу `reduce()` у класі Stream або за допомогою методу `reduce()` у класі Stream API.**

**Синтаксис методу `reduce()` у Stream API:**

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
T reduce(T identity, BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
```

- Перший варіант методу `reduce()` використовується, коли ми хочемо згорнути всі елементи потоку в одне значення з допомогою бінарного оператора.
- Другий варіант методу `reduce()` дозволяє вказати початкове значення (identity), яке використовується як початкове значення для згортання.
- Третій варіант методу `reduce()` використовується, коли ми працюємо з паралельним потоком та ми маємо комбінатор, який об'єднує проміжні результати обробки потоку.

**Приклад використання методу `reduce()` для обчислення суми елементів списку:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);
System.out.println("Sum: " + sum);
```

**У цьому прикладі ми використовуємо метод `reduce()` для згортання елементів списку у суму. Початкове значення встановлено на 0, а бінарний оператор `(a, b) -> a + b` об'єднує два елементи, додаючи їх разом.**

# Що таке паралельні потоки?
**Паралельні потоки (Parallel Streams) в Java є механізмом, який дозволяє виконувати обробку елементів потоку паралельно у багатьох потоках, що призводить до поліпшення продуктивності та зменшення часу виконання завдань.**

**Паралельні потоки використовуються у контексті Stream API в Java для обробки великих об'ємів даних. Вони автоматично розподіляють обробку елементів потоку між доступними потоками в системі, що дозволяє використовувати потенціал багатоядерних та багатопроцесорних систем.**

- **`parallelStream()` є методом в Java, який використовується для створення паралельного потоку даних з колекцій або інших джерел даних.**

**Основні особливості паралельних потоків:**

1. Автоматичний розподіл завдань: Паралельні потоки автоматично розподіляють обробку елементів потоку між доступними потоками, що дозволяє використовувати багатоядерні та багатопроцесорні системи для поліпшення продуктивності.
2. Збереження порядку даних: Паралельні потоки забезпечують правильну обробку елементів потоку, зберігаючи їх початковий порядок. Результати обробки виводяться у правильному порядку відповідно до послідовності елементів у потоці.
3. Управління потоками: Java самостійно керує створенням та керуванням потоками, що дозволяє спростити роботу з паралельними потоками без необхідності вручну створювати та керувати потоками.
4. Безпека: Паралельні потоки враховують потенційні проблеми багатопотокової обробки, такі як заблокування, зміни спільних ресурсів та інші багатопотокові проблеми. Вони забезпечують безпеку виконання завдяки внутрішньому механізму синхронізації.

**Використання паралельних потоків дозволяє ефективно обробляти великі об'єми даних, розподіляючи роботу між багатьма потоками та використовуючи можливості багатоядерних та багатопроцесорних систем. Однак, варто враховувати особливості паралельної обробки, такі як синхронізація та безпека, для ефективного використання цього механізму.**

# Які інтерфейси є у Stream?

1. `Stream<T>`: Представляє послідовний потік елементів типу `T`.
2. `IntStream`, `LongStream`, `DoubleStream`: Спеціалізовані потоки для цілих чисел, довгих чисел і чисел з плаваючою крапкою відповідно.
3. `BaseStream`: Базовий інтерфейс для всіх Stream, надає загальні операції, спільні для всіх типів Stream.
4. `Collector`: Використовується для збору елементів потоку в різні контейнери або результати.
5. `Spliterator`: Використовується для розділення послідовності елементів потоку на частини для паралельної обробки.
6. `Iterator`: Інтерфейс для послідовного отримання елементів з колекції або послідовності.
7. `Predicate`: Використовується для перевірки умови на елементі потоку. Повертає значення типу `boolean`.
8. `Function`: Використовується для перетворення одного типу даних в інший або отримання результату на основі вхідних даних.
9. `Consumer`: Використовується для виконання дій над елементами потоку без повернення результату.
10. `Supplier`: Використовується для створення або надання елементів потоку без вхідних даних.
11. `Comparator`: Використовується для порівняння елементів потоку.
12. `BiPredicate`, `BiFunction`, `BiConsumer`: Подібні до `Predicate`, `Function` і `Consumer`, але приймають два аргументи замість одного.

**Ці інтерфейси дозволяють робити різноманітні операції з потоками даних, виконувати фільтрацію, мапування, згортання, 
сортування та інші операції.
Кожен інтерфейс має свої власні методи, які виконують певні функціональні дії з елементами потоку.**



# Навіщо в Stream використовують Predicate, Consumer, Function?

**Використання інтерфейсів Predicate, Consumer і Function в Stream дозволяє робити операції з елементами потоку, які можуть змінювати, фільтрувати або перетворювати дані. Вони допомагають виконувати різні дії над елементами потоку, що робить операції більш гнучкими та зручними для програмування.**

## Ось які ролі виконують ці інтерфейси в Stream:
____________________________
## 1. Predicate: 
**Predicate використовується для фільтрації елементів потоку. Він дозволяє вказати умову, яку повинні задовольняти елементи, щоб бути включеними в результат. При використанні методу `filter()` потоку, Predicate визначає, які елементи будуть пропущені через фільтр.**

**У Java, інтерфейс Predicate є частиною пакету java.util.function і використовується для представлення логічної умови, яка може бути перевірена для певного об'єкта. Він приймає один аргумент і повертає булеве значення, вказуючи, чи задовольняє даний об'єкт вказану умову.**

**Інтерфейс Predicate має один абстрактний метод:**

```java
boolean test(T t);
```
**Цей метод використовується для перевірки умови на об'єкті типу T. Він повертає значення true, якщо об'єкт задовольняє умову, і false в іншому випадку.**

**Predicate може бути використаний в різних сценаріях, наприклад:**

1. Фільтрація елементів: Предикати можуть використовуватись для фільтрації колекцій або потоків елементів, залишаючи лише ті елементи, які задовольняють певну умову.
2. Перевірка умови: Предикати можуть бути використані для перевірки певних умов на об'єктах, наприклад, чи є число парним, чи має рядок певну довжину тощо.
3. Складні умови: Предикати можуть бути поєднані за допомогою логічних операцій (AND, OR, NOT) для створення складних умов, що можуть бути перевірені на об'єктах.

**Наведемо приклад використання Predicate для фільтрації елементів списку:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Predicate<Integer> evenPredicate = number -> number % 2 == 0;
List<Integer> evenNumbers = numbers.stream()
                                   .filter(evenPredicate)
                                   .collect(Collectors.toList());
System.out.println(evenNumbers); // Output: [2, 4]
```

**У цьому прикладі ми використовуємо Predicate для створення умови, яка перевіряє, чи є число парним. Потім ми використовуємо цей Predicate для фільтрації чисел у списку, залишаючи лише парні числа.**

## 2. Consumer: 
**Consumer використовується для виконання дій над елементами потоку без повернення результату. Він дозволяє вказати, яку дію потрібно виконати з кожним елементом потоку. При використанні методів `forEach()` або `peek()` потоку, Consumer визначає, яку дію потрібно виконати над кожним елементом.**

**У Java, інтерфейс Consumer є частиною пакету java.util.function і використовується для виконання дії над об'єктом без повернення результату. Він приймає один аргумент і нічого не повертає.**

**Інтерфейс Consumer має один абстрактний метод:**

```java
void accept(T t);
```
**Цей метод приймає об'єкт типу T і виконує певну дію над цим об'єктом. Метод не повертає жодного значення.**

**Consumer може бути використаний в різних сценаріях, наприклад:**

1. Обробка елементів: Consumer може бути використаний для обробки кожного елемента в колекції або потоці даних без повернення результату. Наприклад, він може виконувати друк елементів, запис у файл або оновлення стану об'єктів.
2. Передача дій: Consumer може бути використаний для передачі дій (функцій) як аргументів у інші методи. Наприклад, він може бути використаний для передачі дії, яку потрібно виконати над кожним елементом, в метод `forEach()` колекцій або потоків.
3. Складні операції: Consumer може бути поєднаний з іншими функціональними інтерфейсами для створення складних операцій. Наприклад, використання Consumer разом з Predicate і Function може дозволити фільтрувати елементи та виконувати певну дію над ними.

**Приведемо приклад використання Consumer для виводу елементів списку:**

```java
List<String> names = Arrays.asList("John", "Alice", "Bob");
Consumer<String> printConsumer = name -> System.out.println(name);
names.forEach(printConsumer);
```

**У цьому прикладі ми створюємо Consumer, який просто друкує кожне ім'я. Потім ми використовуємо цей Consumer разом з методом `forEach()`, щоб виконати цю дію над кожним елементом списку `names`.**

## 3.Function: 

**Function використовується для перетворення елементів потоку з одного типу на інший або для отримання результату на основі вхідних даних. Він дозволяє вказати, як перетворити або обробити кожен елемент потоку для отримання вихідних результатів. При використанні методів `map()`, `flatMap()` або `reduce()` потоку, Function визначає, як обчислити нове значення або перетворити елементи потоку.**

**У Java, інтерфейс Function є частиною пакету java.util.function і використовується для визначення функцій, які приймають один аргумент і повертають результат. Він представляє функцію, яка може бути застосована до об'єкта одного типу для отримання об'єкта іншого типу.**

**Інтерфейс Function має один абстрактний метод:**

```java
R apply(T t);
```
**Цей метод приймає об'єкт типу T і повертає об'єкт типу R. Він описує дію, яка застосовується до вхідного об'єкта для отримання вихідного об'єкта.**

**Function може бути використаний в різних сценаріях, наприклад:**

1. Мапування елементів: Function може бути використаний для мапування (перетворення) елементів з одного типу на інший. Наприклад, він може бути використаний для перетворення чисел з одного типу на інший або для отримання деякої властивості об'єкта.
2. Обробка даних: Function може бути використаний для обробки даних шляхом застосування деяких операцій до вхідних об'єктів та отримання вихідних результатів. Наприклад, він може бути використаний для обчислення середнього значення елементів, об'єднання рядків тощо.
3. Послідовні операції: Function може бути поєднаний з іншими функціональними інтерфейсами для створення послідовних операцій. Наприклад, використання Function разом з Predicate і Consumer може дозволити фільтрувати елементи, обробляти їх і виконувати певні дії.

**Приведемо приклад використання Function для мапування чисел на їх квадрати:**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Function<Integer, Integer> squareFunction = number -> number * number;
List<Integer> squares = numbers.stream()
                               .map(squareFunction)
                               .collect(Collectors.toList());
System.out.println(squares); // Output: [1, 4, 9, 16, 25]
```

**У цьому прикладі ми створюємо Function, який мапує числа на їх квадрати. Потім ми використовуємо цей Function разом з методом `map()` потоку чисел, щоб застосувати функцію до кожного числа та отримати список квадратів чисел.**
________________
### _Використання цих інтерфейсів дозволяє програмістам легко виконувати різні операції з елементами потоку, такі як фільтрація, обробка та перетворення даних. Вони дозволяють писати більш зрозумілий і компактний код, який може бути легко змінений або розширений у майбутньому_
________________
